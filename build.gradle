import java.nio.file.Files
import java.util.function.Function
import java.util.function.Predicate
import java.util.stream.Collectors

buildscript {
    dependencies {
        classpath 'org.apache.commons:commons-lang3:3.12.0'
    }
}

plugins {
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.0.10'
    id 'org.jetbrains.kotlin.jvm' version '1.8.10'
}

group = 'home'
version = '1.0-SNAPSHOT'

repositories { mavenCentral() }
application { mainClassName = 'org.home.app.run.Application_devKt' }
test { useJUnitPlatform() }

def koin_version = "3.2.0-beta-1"

dependencies {

    implementation('home:utils') {
        version {
            branch = 'main'
        }
    }

    implementation("io.insert-koin:koin-core:$koin_version")
    implementation 'no.tornado:tornadofx:1.7.20'
    implementation 'org.jetbrains.kotlin:kotlin-stdlib'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.0-Beta'
    implementation 'org.apache.commons:commons-lang3:3.12.0'

    implementation 'com.eclipsesource.minimal-json:minimal-json:0.9.5'

    testImplementation 'org.testfx:testfx-core:4.0.13-alpha'
    testImplementation 'org.jetbrains.kotlin:kotlin-test-junit'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'

    testImplementation 'com.google.guava:guava-collections:r03'
    testImplementation 'com.google.guava:guava:13.0'
}

compileKotlin { kotlinOptions.jvmTarget = '16' }
compileTestKotlin { kotlinOptions.jvmTarget = '16' }

javafx {
    version = '19'
    modules = ['javafx.base', 'javafx.controls', 'javafx.fxml', 'javafx.graphics']
    configuration = 'implementation'
}

task fatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': mainClassName
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}

ext {
    sl = File.separator
    close = false
    resourcesFolder = "${projectDir.path}${sl}src${sl}main${sl}resources${sl}"
    playerPropPrefix = "player"
    application = "application"
    application_dev = "application-dev"
    application_debug = "application-debug"
}

def sl = rootProject.ext.sl
def application_dev = rootProject.ext.application_dev

String java = "${System.getProperty("java.home")}${sl}bin${sl}java"

def jarFullpath = "${project.path}\\build\\libs\\${project.name}-${project.version}.jar"

def javaCp = [java, "-classpath", sourceSets.main.runtimeClasspath.getAsPath()]
def javaJar = [java, "-jar", jarFullpath, mainClassName]

def playersNumber = 4
def propsList = createProperties(playersNumber)

task createProperties {
    deleteProperties()
    createProperties(playersNumber)
}

task player0 { doLast { runDev(concat(javaCp, mainClassName), playerProp(0)) } }
task player1 { doLast { runDev(concat(javaCp, mainClassName), playerProp(1)) } }
task player2 { doLast { runDev(concat(javaCp, mainClassName), playerProp(2)) } }
task player3 { doLast { runDev(concat(javaCp, mainClassName), playerProp(3)) } }
task player4 { doLast { runDev(concat(javaCp, mainClassName), playerProp(4)) } }
task player5 { doLast { runDev(concat(javaCp, mainClassName), playerProp(5)) } }
task player6 { doLast { runDev(concat(javaCp, mainClassName), playerProp(6)) } }
task player7 { doLast { runDev(concat(javaCp, mainClassName), playerProp(7)) } }

task multiscreenCheck { doLast { runDev(concat(javaCp, 'org.home.app.run.Multiscreen_checkKt')) } }

tasks.player0.dependsOn(build)
tasks.player0.dependsOn(createProperties)
tasks.multiscreenCheck.dependsOn(build)

def runDev(List<String> command, Object... args) {
    exec { commandLine concat(command, toString(args)) }
}

def pidsFile = createFile("$projectDir${sl}pids.txt")

task runPlayers {
    doLast {
        def processes = new ArrayList<Process>()

        for (int player = 0; player < propsList.size(); player++) {
            def props = propsList.get(player)
            def process = process(concat(javaCp, mainClassName), props)
            processes.add(process)
        }

        def writer = new PrintWriter(pidsFile)

        processes.forEach {
            writer.println(it.pid())
        }

        writer.flush()
        writer.close()
    }
}

static def process(List<String> command, Object... args) {
    def process = new ProcessBuilder(concat(command, toString(args))).start()
    println "process ${process.pid()} was started"
    return process
}

tasks.runPlayers.dependsOn(build)

task killPlayers {
    doLast {
        Files
           .readAllLines(pidsFile.toPath()).stream()
           .forEach {
               def pid = Integer.valueOf(it)
               ProcessHandle.of(pid).ifPresent(ProcessHandle::destroy)
               println "process ${it} was killed"
           }
    }
}

static def toString(Object... args) {
    return Arrays.stream(args).map(Object::toString).collect(Collectors.toList())
}

static def concat(List<String> args1, List<String> args2) {
    def all = new ArrayList<String>(args1)
    all.addAll(args2)
    return all
}

static def concat(String arg, List<String> args) {
    def all = new ArrayList<String>(args)
    all.add(arg)
    return all
}

static def concat(List<String> args, String arg) {
    def all = new ArrayList<String>(args)
    all.add(arg)
    return all
}

static def createFile(String path) {
    def file = new File(path)
    file.createNewFile()
    return file
}

List<String> createProperties(Integer playersNumber) {
    def properties = new ArrayList<String>(playersNumber)
    def applicationFile = new File(propFilepath((String) rootProject.ext.application))
    def applicationDebugFile = new File(propFilepath((String) rootProject.ext.application_debug))

    def lines = Files.readAllLines(applicationFile.toPath())
    def debugLines = Files.readAllLines(applicationDebugFile.toPath())

    for (playerNumber in 0..<playersNumber) {
        properties.add(createProp(playerNumber, playersNumber, lines, debugLines))
    }
    return properties
}

private String createProp(int playerNumber, int playersNumber, List<String> lines, List<String> debugLines) {
    def devLines = new ArrayList<String>()
    String playerProp = playerProp(playerNumber)

    if (playerNumber == 0) {
        devLines.add(getLine(lines, it -> it.contains("currentPlayer")))
    } else {
        devLines.add("currentPlayer=$playerProp")
    }
    devLines.add("player=$playerNumber")
    devLines.add("players=$playersNumber")

    devLines.addAll(debugLines)
    addIfAbsent(lines, devLines)

    def propFile = createFile(propFilepath(playerProp))

    Files.write(propFile.toPath(), devLines)
    return playerProp
}

static def addIfAbsent(List<String> source, List<String> target) {
    def strings = source
            .stream()
            .filter(s -> notIn(target, t -> propNameEqual(t, s)))
            .toList()

    target.addAll(strings)
}


def static notIn(List<String> strings, Function<String, Boolean> predicate) {
    return !strings.stream().anyMatch(s -> predicate(s))
}

def static propNameEqual(String line, String another) {
    return extractPropName(line) == extractPropName(another)
}

static def extractPropName(String line) {
    line.substring(0, line.indexOf("="))
}

def static getLine(List<String> lines, Predicate<String> predicate) {
    lines.stream().filter(predicate).findFirst().get()
}

def deleteProperties() {
    def dir = new File(rootProject.ext.resourcesFolder)
    for(File file: dir.listFiles())
        if (file.name.matches(rootProject.ext.playerPropPrefix + "-[\\d]+.properties")) file.delete()
}

private String playerProp(Integer i) {
    if (i == 0) return rootProject.ext.application_dev
    return "${rootProject.ext.playerPropPrefix}-${i}"
}

private String propFilepath(String prop) {
    return "${rootProject.ext.resourcesFolder}${prop}.properties"
}
