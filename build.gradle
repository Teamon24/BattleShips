import org.apache.commons.lang3.ArrayUtils
import org.apache.commons.lang3.StringUtils

import java.util.concurrent.Executors
import java.util.function.BiConsumer
import java.util.function.Consumer
import java.util.stream.Collectors

buildscript {
    dependencies {
        classpath 'org.codehaus.gpars:gpars:1.2.1'
        classpath 'org.apache.commons:commons-lang3:3.12.0'
        classpath 'org.apache.commons:commons-lang3:3.12.0'
        classpath 'commons-io:commons-io:2.11.0'
    }
}

plugins {
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.0.10'
    id 'org.jetbrains.kotlin.jvm' version '1.8.10'
}

group = 'com.test'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

application {
    mainClassName = 'org.home.ApplicationKt'
}

test {
    useJUnitPlatform()
}

sourceSets {
    main.kotlin.srcDirs = ['src/main/kotlin']
    main.resources.srcDirs = ['src/main/resources']
}

dependencies {
    implementation 'no.tornado:tornadofx:1.7.20'
    testImplementation 'org.jetbrains.kotlin:kotlin-test-junit'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'
    implementation 'org.jetbrains.kotlin:kotlin-stdlib'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.0-Beta'
    implementation 'io.insert-koin:koin-core:3.3.3'
    implementation 'org.apache.commons:commons-lang3:3.12.0'
    implementation 'com.google.guava:guava-collections:r03'
    implementation 'com.google.guava:guava:13.0'
}

compileKotlin {
    kotlinOptions.jvmTarget = '17'
}

compileTestKotlin {
    kotlinOptions.jvmTarget = '17'
}

javafx {
    version = '19'
    modules = ['javafx.base', 'javafx.controls', 'javafx.fxml', 'javafx.graphics']
    configuration = 'implementation'
}

task fatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': mainClassName
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}

ext {
    sl = File.separator
    close = false
    resourcesFolder = "${projectDir.path}${sl}src${sl}main${sl}resources${sl}"
    playerPropPrefix = "player"
}

def sl = rootProject.ext.sl
def application = "application"
def playersNumber = 6

def propsList = concat(application, toString(createProperties(playersNumber)))

String java = "${System.getProperty("java.home")}${sl}bin${sl}java"

def javaCp =
[java, "-classpath", sourceSets.main.runtimeClasspath.getAsPath()]

def javaJar =
[java, "-jar", "${project.path}\\build\\libs\\${project.name}-${project.version}.jar", mainClassName]

def pidsFile = createFile("$projectDir${sl}pids.txt")


task createProperties {
    deleteProperties()
    createProperties(playersNumber - 1)
}

task server  { doLast { runApp(concat(javaCp, mainClassName), application, 0, playersNumber - 1) } }
task player0 { doLast { runApp(concat(javaCp, mainClassName), player(0),   1, playersNumber - 1) } }
task player1 { doLast { runApp(concat(javaCp, mainClassName), player(1),   2, playersNumber - 1) } }
task player2 { doLast { runApp(concat(javaCp, mainClassName), player(2),   3, playersNumber - 1) } }
task player3 { doLast { runApp(concat(javaCp, mainClassName), player(3),   4, playersNumber - 1) } }
task player4 { doLast { runApp(concat(javaCp, mainClassName), player(4),   5, playersNumber - 1) } }
task player5 { doLast { runApp(concat(javaCp, mainClassName), player(5),   6, playersNumber - 1) } }
task player6 { doLast { runApp(concat(javaCp, mainClassName), player(6),   7, playersNumber - 1) } }

task multiscreenCheck { doLast { runApp(concat(javaCp, 'org.home.Multiscreen_checkKt')) } }

tasks.server.dependsOn(build)
tasks.server.dependsOn(createProperties)
tasks.multiscreenCheck.dependsOn(build)

def runApp(List<String> command, Object... args) {
    exec { commandLine concat(command, toString(args)) }
}

task runPlayers {
    doLast {
        def propsNumber = propsList.size()
        def processes = new ArrayList<Process>()

        for (int player = 0; player < propsList.size(); player++) {
            def props = propsList.get(player)
            def process = process(concat(javaCp, mainClassName), props, player, propsNumber)
            processes.add(process)
        }

        def writer = new PrintWriter(pidsFile)
        processes.forEach {
            writer.println(it.pid())
        }
        writer.flush()
        writer.close()
    }
}
tasks.runPlayers.dependsOn(build)


task killPlayers {
    doLast {
        def processes = new ArrayList<Integer>()
        readFile(pidsFile, (pid) -> processes.add(Integer.valueOf(pid)))

        processes.forEach {
            ProcessHandle.of(it).ifPresent(ProcessHandle::destroy)
            println "process ${it} was killed"
        }
    }
}






static def process(List<String> command, Object... args) {
    def process = new ProcessBuilder(concat(command, toString(args))).start()
    println "process ${process.pid()} was started"
    return process
}

static def toString(Object... args) {
    return Arrays.stream(args).map(Object::toString).collect(Collectors.toList())
}

static def toString(List<?> args) {
    return args.stream().map(Object::toString).collect(Collectors.toList())
}

static def concat(List<String> args1, List<String> args2) {
    def all = new ArrayList<String>(args1)
    all.addAll(args2)
    return all
}

static def concat(String arg, List<String> args) {
    def all = new ArrayList<String>(args)
    all.add(arg)
    return all
}

static def concat(List<String> args, String arg) {
    def all = new ArrayList<String>(args)
    all.add(arg)
    return all
}

static def createFile(String path) {
    def file = new File(path)
    file.createNewFile()
    return file
}

def createProperties(Integer playersNumber) {
    def properties = new ArrayList<String>(playersNumber)
    StringBuilder stringBuilder = new StringBuilder()

    def applicationProps = new File(propFilepath("application"))
    readFile(applicationProps, (line) -> stringBuilder.append(line).append("\n"))
    for (i in 0..<playersNumber) {
        String playerName = player(i)
        properties.add(playerName)
        def filePath = propFilepath(playerName)
        toFile(
                (writer, content) -> writer.write(content),
                filePath,
                content(stringBuilder, playerName)
        )
    }
    return properties
}

def deleteProperties() {
    def dir = new File(rootProject.ext.resourcesFolder)
    for(File file: dir.listFiles())
        if (file.name.matches(rootProject.ext.playerPropPrefix + "-[\\d]+.properties")) file.delete()
}

private static void toFile(BiConsumer<PrintWriter, String> op, String filepath, String content) {
    def propertiesFile = createFile(filepath)
    def writer = new PrintWriter(propertiesFile)
    op.accept(writer, content)
    writer.flush()
    writer.close()
}

private String player(i) {
    return "${rootProject.ext.playerPropPrefix}-${i}"
}

private static String content(StringBuilder stringBuilder, String playerName) {
    def strings = ArrayUtils.remove(stringBuilder.toString().split("\n"), 0)
    String currentPlayerProp = "currentPlayer=$playerName"
    def propsContent = ArrayUtils.addFirst(strings, currentPlayerProp)
    return StringUtils.join(propsContent, "\n")
}

private String propFilepath(String prop) {
    return "${rootProject.ext.resourcesFolder}${prop}.properties"
}

static def readFile(File file, Consumer<String> body) {
    def reader = new BufferedReader(new FileReader(file))
    String line = reader.readLine()

    while(line != null) {
        line.trim()
        body.accept(line)
        line = reader.readLine()
    }
}