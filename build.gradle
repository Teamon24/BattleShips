import org.apache.commons.lang3.StringUtils

import java.util.function.BiConsumer
import java.util.function.Consumer
import java.util.stream.Collectors

buildscript {
    dependencies {
        classpath 'org.apache.commons:commons-lang3:3.12.0'
    }
}

plugins {
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.0.10'
    id 'org.jetbrains.kotlin.jvm' version '1.8.10'
}

group = 'home'
version = '1.0-SNAPSHOT'

repositories { mavenCentral() }
application { mainClassName = 'org.home.run.Application_devKt' }
test { useJUnitPlatform() }

def koin_version = "3.2.0-beta-1"

dependencies {

    implementation('home:utils') {
        version {
            branch = 'main'
        }
    }

    implementation("io.insert-koin:koin-core:$koin_version")
    implementation 'no.tornado:tornadofx:1.7.20'
    implementation 'org.jetbrains.kotlin:kotlin-stdlib'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.0-Beta'
    implementation 'org.apache.commons:commons-lang3:3.12.0'

    implementation 'com.eclipsesource.minimal-json:minimal-json:0.9.5'

//    testImplementation("io.insert-koin:koin-test:$koin_version")
//    testImplementation("io.insert-koin:koin-test-junit5:$koin_version")
//    testImplementation 'org.mockito:mockito-core:5.2.0'
//    testImplementation 'net.bytebuddy:byte-buddy:1.14.2'

    testImplementation 'org.testfx:testfx-core:4.0.13-alpha'
    testImplementation 'org.jetbrains.kotlin:kotlin-test-junit'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'

    testImplementation 'com.google.guava:guava-collections:r03'
    testImplementation 'com.google.guava:guava:13.0'
}

compileKotlin { kotlinOptions.jvmTarget = '16' }
compileTestKotlin { kotlinOptions.jvmTarget = '16' }

javafx {
    version = '19'
    modules = ['javafx.base', 'javafx.controls', 'javafx.fxml', 'javafx.graphics']
    configuration = 'implementation'
}

task fatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': mainClassName
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}

ext {
    sl = File.separator
    close = false
    resourcesFolder = "${projectDir.path}${sl}src${sl}main${sl}resources${sl}"
    playerPropPrefix = "player"
    application_dev = "application-dev"
}

def sl = rootProject.ext.sl
def application_dev = rootProject.ext.application_dev

String java = "${System.getProperty("java.home")}${sl}bin${sl}java"

def jarFullpath = "${project.path}\\build\\libs\\${project.name}-${project.version}.jar"

def javaCp = [java, "-classpath", sourceSets.main.runtimeClasspath.getAsPath()]
def javaJar = [java, "-jar", jarFullpath, mainClassName]

def playersNumber = 4
def propsList = concat(application_dev, toString(createProperties(playersNumber)))

task createProperties {
    deleteProperties()
    createProperties(playersNumber)
}

task player0 { doLast { runDev(concat(javaCp, mainClassName), playerProp(0)) } }
task player1 { doLast { runDev(concat(javaCp, mainClassName), playerProp(1)) } }
task player2 { doLast { runDev(concat(javaCp, mainClassName), playerProp(2)) } }
task player3 { doLast { runDev(concat(javaCp, mainClassName), playerProp(3)) } }
task player4 { doLast { runDev(concat(javaCp, mainClassName), playerProp(4)) } }
task player5 { doLast { runDev(concat(javaCp, mainClassName), playerProp(5)) } }
task player6 { doLast { runDev(concat(javaCp, mainClassName), playerProp(6)) } }
task player7 { doLast { runDev(concat(javaCp, mainClassName), playerProp(7)) } }

task multiscreenCheck { doLast { runDev(concat(javaCp, 'org.home.Multiscreen_checkKt')) } }

tasks.player0.dependsOn(build)
tasks.player0.dependsOn(createProperties)
tasks.multiscreenCheck.dependsOn(build)

def runDev(List<String> command, Object... args) {
    exec { commandLine concat(command, toString(args)) }
}

def pidsFile = createFile("$projectDir${sl}pids.txt")

task runPlayers {
    doLast {
        def processes = new ArrayList<Process>()

        for (int player = 0; player < propsList.size(); player++) {
            def props = propsList.get(player)
            def process = process(concat(javaCp, mainClassName), props)
            processes.add(process)
        }

        def writer = new PrintWriter(pidsFile)
        processes.forEach {
            writer.println(it.pid())
        }
        writer.flush()
        writer.close()
    }
}

tasks.runPlayers.dependsOn(build)

task killPlayers {
    doLast {
        def processes = new ArrayList<Integer>()
        readFile(pidsFile, (pid) -> processes.add(Integer.valueOf(pid)))

        processes.forEach {
            ProcessHandle.of(it).ifPresent(ProcessHandle::destroy)
            println "process ${it} was killed"
        }
    }
}

static def process(List<String> command, Object... args) {
    def process = new ProcessBuilder(concat(command, toString(args))).start()
    println "process ${process.pid()} was started"
    return process
}

static def toString(Object... args) {
    return Arrays.stream(args).map(Object::toString).collect(Collectors.toList())
}

static def toString(List<?> args) {
    return args.stream().map(Object::toString).collect(Collectors.toList())
}

static def concat(List<String> args1, List<String> args2) {
    def all = new ArrayList<String>(args1)
    all.addAll(args2)
    return all
}

static def concat(String arg, List<String> args) {
    def all = new ArrayList<String>(args)
    all.add(arg)
    return all
}

static def concat(List<String> args, String arg) {
    def all = new ArrayList<String>(args)
    all.add(arg)
    return all
}

static def createFile(String path) {
    def file = new File(path)
    file.createNewFile()
    return file
}

def createProperties(Integer playersNumber) {
    def properties = new ArrayList<String>(playersNumber)
    def applicationProps = new File(propFilepath("application-dev"))

    for (i in 1..<playersNumber) {
        String playerProp = playerProp(i)
        properties.add(playerProp)
        def filePath = propFilepath(playerProp)
        toFile(
                (writer, content) -> writer.write(content),
                filePath,
                content(applicationProps, playerProp, i, playersNumber)
        )
    }
    return properties
}

def deleteProperties() {
    def dir = new File(rootProject.ext.resourcesFolder)
    for(File file: dir.listFiles())
        if (file.name.matches(rootProject.ext.playerPropPrefix + "-[\\d]+.properties")) file.delete()
}

private static void toFile(BiConsumer<PrintWriter, String> op, String filepath, String content) {
    def propertiesFile = createFile(filepath)
    def writer = new PrintWriter(propertiesFile)
    op.accept(writer, content)
    writer.flush()
    writer.close()
}

private String playerProp(i) {
    if (i == 0) return rootProject.ext.application_dev
    return "${rootProject.ext.playerPropPrefix}-${i}"
}

private static String content(File file, String playerProp, Integer playerNumber, Integer playersNumber) {
    StringBuilder fileContent = new StringBuilder()
    readFile(file, (line) -> fileContent.append(line).append("\n"))
    def lines = Arrays.asList(fileContent.toString().split("\n")) as ArrayList<String>

    set(lines, "currentPlayer", playerProp)
    set(lines, "player", playerNumber)
    set(lines, "players", playersNumber)

    return StringUtils.join(lines, "\n")
}

private static set(ArrayList<String> lines, String prop, Object playerProp) {
    String propWithEqual = "$prop="
    def line = lines.stream().filter(it -> it.contains(propWithEqual)).findFirst().get()
    def index = lines.indexOf(line)
    lines.set(index, "$prop=$playerProp")
}

private String propFilepath(String prop) {
    return "${rootProject.ext.resourcesFolder}${prop}.properties"
}

static def readFile(File file, Consumer<String> body) {
    def reader = new BufferedReader(new FileReader(file))
    String line = reader.readLine()

    while(line != null) {
        line.trim()
        body.accept(line)
        line = reader.readLine()
    }
}